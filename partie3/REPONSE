---
title: C++ SV Project
author: Jeremy Mion (261178)
date: December 11th 2018
---

# Q.1

## Q.1.1
The only logical thing to di is to create a private methode. In my case "clamp"

## Q.1.2
The reason that the default = and copy constructor are sufficient is that they both do a surface copy of the elements. Codding them by default allows the user of our class to know that they can safely use these constrcutors.

## Q.1.3
A double loop will allow for a more concise piece of code. There is no point in describing it in gory details in this file. See the actual code for implementation details.

## Q.1.4
Taking a const reference is almost always better. The only case where we decided to not use a const ref, is in the constructor since we want a copy of the vector to operate on it.

## Q.1.5
All the methodes that do not affect the Object should be constant. This is extremely important since C++ is strict on how it manages const functions. To see which ones where declared as const see the CircularCollider.hpp file.

## Q.1.6
We are simply adding another way to call : we are not writing code that has any functionality. This is important because it allows use to ensure that all of the functions that are designed to have the same behavior behave in the same way.
	isCircularColliderInside(other)
	isColliding(other);
	isPointInside(point);

## Q.1.7
I chose an internal definition for most of the functions because there equivalent in non operator function calls are also internal.

## Q.1.8
For which functions are receiving parameters by reference see .hpp. In all cases where we do not need a copy of the object to operate on it is better to use a const reference since it will improve performance.

## Q.1.9
See CircularCollider.hpp for the list on functions that we decided to declare as const.

# Q.2

## Q.2.1
The draw method should be const. The other ones will make modifications to the environment, therefor they cannot be constant.

## Q.2.2
Use the delete of the operator= and the copy constructor.

```C++
    /*!
     * Disabeling copy constructor since this is a large object that should not be copied.
     */
    Environment(const Environment&) = delete;
    Environment& operator=(const Environment& env) = delete;
```

## Q.2.3
This means that when the Environment is destroyed it needs to destroy all the Animals.

## Q.2.4
### Warning to check with others.
The definition of the use of the different keys is done in the EnvTest

HELP HELP HELP


## Q.2.5
Well we clearly want one method that will calculate the force that is being applied to the automaton. This method called attractionForce will return the force that the automaton is experiencing. This will allow classes inheriting of ChassingAutomaton to simply redefine the attractionForce and have the wanted behavior. The methode prototypes are as follows:

```C++
    /*!
     * Calculates the attraction force that the automaton is experiencing
     * @return force that are being applied to the robot.
     */
    Vec2d attractionForce() const ;

    /*!
     * Makes the automaton moved based of of the force that it is experiencing.
     * @param force that the robot is experiencing
     * @param dt time that has passed since previous update
     */
    void updateMovementVariables(const Vec2d& force, const sf::Time dt );
```

## Q.2.6
We will for now declare a default value in the constructor of ChassingAutomaton. We have added it to the consctructor with a default value.
We will adapt how this enum is set, once we have a better grasp of the context in which it would need to be changed. The enum names are of course capitalized to respect the convention that constants are written in capital letters. The main issue with using enums is of course that we cannot assign floating point values to the elements of an enum. Therefor we had multiple possibilities that where present. Store the enum as integer values by multiplying by a factor 10. This is far from ideal since it means that there is information that is encoded into the enum but that can be misinterpreted. The solution that we decided to apply in this case is to use a private methode to resolve the enum value to it's floating point equivalent.

## Q.2.7
The animal is a seperate entity. Therefor we can imagine that classes that extend the Animal class will want to influence the rotation of the animal. There is no reason why an external class such as the environment should be able to influence the rotation of the automaton. For the method setPosition does not exist since I have not had any use for it so far.
.

## Q.2.8
In the method draw of the Environment we need to call the draw of Animals.

## Q.2.9
This is done to break encapsulation to be able to test the animal class by setting the rotation. We need this for the test

## Q.2.10
A list of Vect2. This wo...

# Q.3

## Q.3.1
All of these methods are declared as abstract : *etStandardMaxSpeed, getMass, getRandomWalkRadius, getRandomWalkDistance, getRandomWalkJitter, getViewRange et getViewDistance* . We need to use the override keyword every time that we want to redefine one of the abstract methods. Here since we clearly do not know the implementation of these methods in the Animal class we will force the children of the class to define the behavior that they will provide.

## Q.3.2

We need to change the line where energy is indicated. For example:

```JSON
"energy":{
               "initial":80,
               "min mating male":450,
               "min mating female":800,
               "loss mating male":200,
               "loss female per child":100,
               "loss factor":0.001
            },
```

## Q.3.3

The classes Updatable and Drawable are being used as interfaces. The concept of interfaces does not exist in C++ but can be mocked with a 100% abstract class. The idea is that all objects that can be drawn can be seen as drawable objects. It is a contract that all subclasses have to fulfill. In our project we will consider that a CircularCollider is Drawable. The idea of implementing at this level is that all the subclasses can and should call the implementation of there parent class. They will therefor all inherit of the possibility of drawing a visual representation of the collider in debug mode. In our project we will assume that we can have circularCollider's that are static object and therefor don't need to be updated. We will consider that all OrganicEnity are Updatable.

## Q.3.4

It a way to build a program not makes modifications not easy due to the lack of maintainability. Removing or adding new classes require a large amount of work to rework existing code to add new tests. Using a double dispatch is a much better way of doing things since it relinquishes the control of who can eat what to the class itself.

## Q.3.5

It is interesting to implement the draw method for the circular collider in it's own class. It makes sense that a circular collider is in charge of displaying itself for debugging purposes. We therefor changed the inheritance of Drawable, moving it up from OrganicEnity to CircularCollider. For the moment there is no specific need / or logic to justify the circular collider having an update method. Therefor the implementation of the Updatable "interface" will remain in Animal. A explicit call to CircularCollider::draw needs to be made at the beginning of the draw method of any children to enable the drawing of the circular collider.

## Q.3.6

The best implementation in this case is to provide 2 methods that are used in the default implementation of isDead(). These methods will allow access to the longevity and min_energy_level. Of course we will declare them as virtual and allow any of the classes that implement to change the definition of what the default values are. In this way the method to determine if the organicEnity is dead can remain in the OrganicEnity class and the sub classes have the possibility to modify it's behavior by changing the getters.

## Q.3.7

When the OrganicEntities die of old age the environment needs to free the memory that was allocated when we created the animal. This is crucial to avoid memory leeks. The environment is in charge of checking at each update cycle if the entity is dead and unregistering them. If this task becomes a large overhead one would imagine using a queue for every type of animal. This would improve performance significantly if there is a lot of animals being simulated. We will consider this in case performance becomes an issue.

## Q.3.8

 First of all we we need to define the condition when the Animal will be starving. This information will be used in getMaxSpeed. For the definition of when an animal is starving we decided that each animal can be starving at a different energy level. For proper use we therefor added an *scorpion_energy_starving* and *gerbil_energy_starving* to our app JSON config file. We used a virtual method to define the updateState leaving the choice of the value to return up to the non abstract animals. With this solution we are respecting the app design and choice of keeping all of these parameters modifiable at run time. We also added *animal_starving_speed_factor* to the JSON because it is the only logical place where such a setting should go. We do not want to affect the state that the animal is in since we would like the animal to behave is it normally does but in a weaker form (moving less fast).

## Q.3.8
Exacly in the same way as previous methodes. But only thing that we will change that we haven't done in previous double dispatch is to define the method in animal. This default implementation 

## Q.3.9
#What is wanted???

## Q.3.10
Exactly like for mate we use double dispatch to have the type of both this and mate. We define method *meet* and *meetManagement*. *Meet* calls *meetManagemetn* which takes care of dealing with the animals matting. The matting involves changes to the animals matting. Since all the fields are defined in animal we have defined a *procreate* method that will take car of making the appropriate changes to the animal.

## Q.3.11

We will put in place the gestation time by creating a sf::Time variable that will be used to track the amount of time that the animal has been in gestation.

## Q.3.12

The method give birth is defined in the *Animal* class and all of it's children. The definition in the *Animal* class only determines if the animal can give birth. It is another check to ensure that no male animals give birth. This check should be redundant since this method should only be called by females. But to avoid missus of this method in the future we felt like the proper way of defining this giveBirth method was to provide a check.

## Q.3.13
The number of babies is stored in the animal. This attribute has a getter provided for it ensuring that if a male animal calls the method it will return 0. It is logical that a male cannot have children.


## Q.3.14
It is better to avoid storing pointers to organic entity in the animal if possible. This provides storage for pointers that could be used when the organic entity disappears from the field of view.


## QUESTIONS
Why are we declaring the eatable method in all the subclasses? It is the same everywhere. And why not use a visitor.
* See for access rights to eatable methods
* Whay are we not using the state running away to make the animals run away from the scorpion. Need to check what is wrongs
* Why is there no to string on a enum.


## CONCEPTION

I added a macros utility file where I will put all the macros that will be utilities for this project. This includes for now the parameters to suppress unused attributes for GCC. This is done here to allow flexibility in case we change compilers since the suppress warning flags are not part of the C norm but are specific to GCC.